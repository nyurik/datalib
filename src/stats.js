var util = require('./util');
var type = require('./import/type');
var gen = require('./generate');
var distribution = require('./distribution');

var stats = {};

// Collect unique values.
// Output: an array of unique values, in first-observed order
stats.unique = function(values, f, results) {
  f = util.$(f);
  results = results || [];
  var u = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    results.push(v);
  }
  return results;
};

// Return the length of the input array.
stats.count = function(values) {
  return values && values.length || 0;
};

// Count the number of non-null, non-undefined, non-NaN values.
stats.count.valid = function(values, f) {
  f = util.$(f);
  var v, i, n, valid = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) valid += 1;
  }
  return valid;
};

// Count the number of null or undefined values.
stats.count.missing = function(values, f) {
  f = util.$(f);
  var v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v == null) count += 1;
  }
  return count;
};

// Count the number of distinct values.
// Null, undefined and NaN are each considered distinct values.
stats.count.distinct = function(values, f) {
  f = util.$(f);
  var u = {}, v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    count += 1;
  }
  return count;
};

// Construct a map from distinct values to occurrence counts.
stats.count.map = function(values, f) {
  f = util.$(f);
  var map = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    map[v] = (v in map) ? map[v] + 1 : 1;
  }
  return map;
};

// Compute the median of an array of numbers.
stats.median = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  return stats.quantile(values, 0.5);
};

// Computes the quartile boundaries of an array of numbers.
stats.quartile = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  var q = stats.quantile;
  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];
};

// Compute the quantile of a sorted array of numbers.
// Adapted from the D3.js implementation.
stats.quantile = function(values, f, p) {
  if (p === undefined) { p = f; f = util.identity; }
  f = util.$(f);
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = +f(values[h - 1]),
      e = H - h;
  return e ? v + e * (f(values[h]) - v) : v;
};

// Compute the sum of an array of numbers.
stats.sum = function(values, f) {
  f = util.$(f);
  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) sum += v;
  }
  return sum;
};

// Compute the mean (average) of an array of numbers.
stats.mean = function(values, f) {
  f = util.$(f);
  var mean = 0, delta, i, n, c, v;
  for (i=0, c=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
    }
  }
  return mean;
};

// Compute the sample variance of an array of numbers.
stats.variance = function(values, f) {
  f = util.$(f);
  if (!util.isArray(values) || values.length < 2) return 0;
  var mean = 0, M2 = 0, delta, i, c, v;
  for (i=0, c=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
      M2 = M2 + delta * (v - mean);
    }
  }
  M2 = M2 / (c - 1);
  return M2;
};

// Compute the sample standard deviation of an array of numbers.
stats.stdev = function(values, f) {
  return Math.sqrt(stats.variance(values, f));
};

// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.
stats.modeskew = function(values, f) {
  var avg = stats.mean(values, f),
      med = stats.median(values, f),
      std = stats.stdev(values, f);
  return std === 0 ? 0 : (avg - med) / std;
};

// Find the minimum value in an array.
stats.min = function(values, f) {
  return stats.extent(values, f)[0];
};

// Find the maximum value in an array.
stats.max = function(values, f) {
  return stats.extent(values, f)[1];
};

// Find the minimum and maximum of an array of values.
stats.extent = function(values, f) {
  f = util.$(f);
  var a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) a = v;
      if (v > b) b = v;
    }
  }
  return [a, b];
};

// Find the integer indices of the minimum and maximum values.
stats.extent.index = function(values, f) {
  f = util.$(f);
  var x = -1, y = -1, a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; x = y = i; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) { a = v; x = i; }
      if (v > b) { b = v; y = i; }
    }
  }
  return [x, y];
};

// Compute the dot product of two arrays of numbers.
stats.dot = function(values, a, b) {
  var sum = 0, i, v;
  if (!b) {
    if (values.length !== a.length) {
      throw Error('Array lengths must match.');
    }
    for (i=0; i<values.length; ++i) {
      v = values[i] * a[i];
      if (v === v) sum += v;
    }
  } else {
    a = util.$(a);
    b = util.$(b);
    for (i=0; i<values.length; ++i) {
      v = a(values[i]) * b(values[i]);
      if (v === v) sum += v;
    }
  }
  return sum;
};

// Compute ascending rank scores for an array of values.
// Ties are assigned their collective mean rank.
stats.rank = function(values, f) {
  f = util.$(f) || util.identity;
  var a = values.map(function(v, i) {
      return {idx: i, val: f(v)};
    })
    .sort(util.comparator('val'));

  var n = values.length,
      r = Array(n),
      tie = -1, p = {}, i, v, mu;

  for (i=0; i<n; ++i) {
    v = a[i].val;
    if (tie < 0 && p === v) {
      tie = i - 1;
    } else if (tie > -1 && p !== v) {
      mu = 1 + (i-1 + tie) / 2;
      for (; tie<i; ++tie) r[a[tie].idx] = mu;
      tie = -1;
    }
    r[a[i].idx] = i + 1;
    p = v;
  }

  if (tie > -1) {
    mu = 1 + (n-1 + tie) / 2;
    for (; tie<n; ++tie) r[a[tie].idx] = mu;
  }

  return r;
};

// Compute the sample Pearson product-moment correlation of two arrays of numbers.
stats.cor = function(values, a, b) {
  var fn = b;
  b = fn ? values.map(util.$(b)) : a;
  a = fn ? values.map(util.$(a)) : values;

  var dot = stats.dot(a, b),
      mua = stats.mean(a),
      mub = stats.mean(b),
      sda = stats.stdev(a),
      sdb = stats.stdev(b),
      n = values.length;

  return (dot - n*mua*mub) / ((n-1) * sda * sdb);
};

// Compute the Spearman rank correlation of two arrays of values.
stats.cor.rank = function(values, a, b) {
  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),
      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),
      n = values.length, i, s, d;

  for (i=0, s=0; i<n; ++i) {
    d = ra[i] - rb[i];
    s += d * d;
  }

  return 1 - 6*s / (n * (n*n-1));
};

// Compute the distance correlation of two arrays of numbers.
// http://en.wikipedia.org/wiki/Distance_correlation
stats.cor.dist = function(values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a;

  var A = stats.dist.mat(X),
      B = stats.dist.mat(Y),
      n = A.length,
      i, aa, bb, ab;

  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {
    aa += A[i]*A[i];
    bb += B[i]*B[i];
    ab += A[i]*B[i];
  }

  return Math.sqrt(ab / Math.sqrt(aa*bb));
};

// Compute the vector distance between two arrays of numbers.
// Default is Euclidean (exp=2) distance, configurable via exp argument.
stats.dist = function(values, a, b, exp) {
  var f = util.isFunction(b) || util.isString(b),
      X = values,
      Y = f ? values : a,
      e = f ? exp : b,
      L2 = e === 2 || e == null,
      n = values.length, s = 0, d, i;
  if (f) {
    a = util.$(a);
    b = util.$(b);
  }
  for (i=0; i<n; ++i) {
    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);
    s += L2 ? d*d : Math.pow(Math.abs(d), e);
  }
  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);
};

// Compute the Cohen's d effect size between two arrays of numbers.
stats.cohensd = function(values,a,b){
    	var X = b ? values.map(util.$(a)) : values;
	var Y = b ? values.map(util.$(b)) : a;
	
	var x1 = stats.mean(X),
	    x2 = stats.mean(Y),
	    n1 = stats.count(X),
	    n2 = stats.count(Y);
	if( (n1+n2-2)<=0 ){
	//if both arrays are of size 1, or one array is empty, there's no effect size
		return 0;
	}  
	
	var s1 = stats.variance(X),
            s2 = stats.variance(Y);
	//s = pooled standard deviation	
	var s = Math.sqrt( ( ((n1-1)*s1) + ((n2-1)*s2) ) / (n1+n2-2));  
	if(s==0){
		return 0;
	}
	else{
		return (x1-x2)/s;
	}
}; 

// Computer the covariance between two arrays of numbers
stats.covariance = function(values,a,b){
	var X = b ? values.map(util.$(a)) : values;
	var Y = b ? values.map(util.$(b)) : a;

	var n = stats.count(X);
	var x1 = stats.mean(X);
	var y1 = stats.mean(Y);
	if(n!= stats.count(Y)){
		//covariance not defined when cardinalities of two sets aren't equal
		return NaN;
	}
	var sum = 0;
	for(var i = 0;i<n;i++){
		sum+=(X[i]-x1)*(Y[i]-y1);
	}
	return sum/(n-1);
};

//Simple linear regression. Returns a "fit" object with slope m, intercept, r value, sum squared residual error.
stats.linearRegression = function(values,a,b){
	var X = b ? values.map(util.$(a)) : values;
  	var Y = b ? values.map(util.$(b)) : a;
	

	if(stats.count(X)!=stats.count(Y)){
		//can't perform simple linear regression with different cardinalities
		throw Error("Array lengths  must match"); 
	}
	var sx = stats.stdev(X);
	var sy = stats.stdev(Y);

	var fit = {};
	fit.m = stats.covariance(X,Y)/stats.variance(X);
	fit.b = stats.mean(Y) - fit.m*stats.mean(X);
	//if this doesn't equal stats.cor(X,Y) then we're in biiiiig trouble
	fit.r = fit.m*sx/sy;		
	var sum = 0;
	var predicted;
	for(var i = 0;i<stats.count(X);i++){
		predicted = fit.m*X[i] + fit.b;
		sum+= Math.pow(predicted-Y[i],2);
	}
	fit.rss = sum;
	return fit;
};

//Construct a z-confidence interval at a given significance level
//Options: array (alpha assumed to be 0.05), array, alpha or mu,sigma,alpha
stats.zConfidenceInterval = function(a,b,c){
	var alpha;
	if(c){
		alpha = c;
	}
	else if(b){
		alpha = b;
	}
	else{
		alpha = 0.05;
	}
	var mu = c ? a : stats.mean(a);
	var sigma = c ? b : stats.stdev(a);
	var gaussian = new distribution.Normal(0,1);
	var  z = gaussian.icdf(1-(alpha/2));
	var SE = sigma/Math.sqrt(stats.count(a));
	return [mu - (z*SE),mu + (z*SE)];
};

//A z-test of means
//Assuming we have a list of values, and a null hypothesis. If no null
//hypothesis, assume our null hypothesis is 0
stats.zTest = function(a,b){	
	var nullH = b ? b : 0;
	var gaussian = new distribution.Normal(0,1);
	var xBar = stats.mean(a);
	//standard error
	var SE = stats.stdev(a) / Math.sqrt(stats.count.valid(a));
	if(SE==0){
		var result = (xBar-nullH)==0 ? 1 : 0;
	}
	var z = (xBar-nullH)/SE;
	z = -1*Math.abs(z);
	//twotailed
	return 2*gaussian.cdf(z);
};

stats.pairedZTest = function(values,a,b){
	var X = b ? values.map(util.$(a)) : values;
	var Y = b ? values.map(util.$(b)) : a;

	var gaussian = new distribution.Normal(0,1);
	var n = (stats.count.valid(X)+stats.count.valid(Y))/2;
	var meanDiff = stats.mean(X)-stats.mean(Y);
	var s = Math.sqrt( (stats.variance(X)/n) + stats.variance(Y)/n);
	//if no variance, or sample size is 1, then return 0 or 1
	if(s==0){
		var result = meanDiff==0 ? 1 : 0;
		return result;
	}
	var z = meanDiff/s;
	
	//two-sided, so twice the one sided cdf
	z = -1*Math.abs(z);
	
	return 2*gaussian.cdf(z);
};


//Construct a t-confidence interval at a given significance level
stats.tConfidenceInterval = function(a,b,c){
	var alpha;
	if(c){
		alpha = c;
	}
	else if(b){
		alpha = b;
	}
	else{
		alpha = 0.05;
	}
     var mu = c ? a : stats.mean(a);
     var sigma = c ? b : stats.stdev(a);
     var t = new distribution.StudentsT(stats.count(a)-1);
     var  A = t.icdf(1-(alpha/2));
     var SE = sigma/Math.sqrt(stats.count(a));
     return [mu - (A*SE),mu + (A*SE)];

};

//Perform a two tailed, one sample Student's t test.
stats.tTest = function(a,b){
	var nullH = b ? b : 0;
        var tdist = new distribution.StudentsT(stats.count.valid(a)-1);
        var xBar = stats.mean(a);
       //standard error
        var SE = stats.stdev(a) / Math.sqrt(stats.count.valid(a));
        if(SE==0){
                 var result = (xBar-nullH)==0 ? 1 : 0;
        }
        var t = (xBar-nullH)/SE;
        t = -1*Math.abs(t);
         //twotailed
         return 2*tdist.cdf(t);
};

//Two independent sample t test with assumed equal population variance
stats.twoSampleTTest = function(values,a,b){
         var X = b ? values.map(util.$(a)) : values;
         var Y = b ? values.map(util.$(b)) : a;
         var n1 = stats.count.valid(X);
	 var n2 = stats.count.valid(Y);
         var tdist = new distribution.StudentsT(n1+n2-2);
         var meanDiff = stats.mean(X)-stats.mean(Y);

//have to pool variance differently than in z tests
         var s = Math.sqrt( ((n1-1)*stats.variance(X) + (n2-1)*stats.variance(Y))/(n1+n2-2));
         //if no variance, or sample size is 1, then return 0 or 1
         if(s==0){
                 var result = meanDiff==0 ? 1 : 0;
                 return result;
         }
         var t = meanDiff/(s*Math.sqrt((1/n1) + (1/n2)));
         
         //two-sided, so twice the one sided cdf
         t = -1*Math.abs(t);
         return 2*tdist.cdf(t);
 }

// Construct a mean-centered distance matrix for an array of numbers.
stats.dist.mat = function(X) {
  var n = X.length,
      m = n*n,
      A = Array(m),
      R = gen.zeros(n),
      M = 0, v, i, j;

  for (i=0; i<n; ++i) {
    A[i*n+i] = 0;
    for (j=i+1; j<n; ++j) {
      A[i*n+j] = (v = Math.abs(X[i] - X[j]));
      A[j*n+i] = v;
      R[i] += v;
      R[j] += v;
    }
  }

  for (i=0; i<n; ++i) {
    M += R[i];
    R[i] /= n;
  }
  M /= m;

  for (i=0; i<n; ++i) {
    for (j=i; j<n; ++j) {
      A[i*n+j] += M - R[i] - R[j];
      A[j*n+i] = A[i*n+j];
    }
  }

  return A;
};

// Compute the Shannon entropy (log base 2) of an array of counts.
stats.entropy = function(counts, f) {
  f = util.$(f);
  var i, p, s = 0, H = 0, n = counts.length;
  for (i=0; i<n; ++i) {
    s += (f ? f(counts[i]) : counts[i]);
  }
  if (s === 0) return 0;
  for (i=0; i<n; ++i) {
    p = (f ? f(counts[i]) : counts[i]) / s;
    if (p) H += p * Math.log(p);
  }
  return -H / Math.LN2;
};

// Compute the mutual information between two discrete variables.
// Returns an array of the form [MI, MI_distance] 
// MI_distance is defined as 1 - I(a,b) / H(a,b).
// http://en.wikipedia.org/wiki/Mutual_information
stats.mutual = function(values, a, b, counts) {
  var x = counts ? values.map(util.$(a)) : values,
      y = counts ? values.map(util.$(b)) : a,
      z = counts ? values.map(util.$(counts)) : b;

  var px = {},
      py = {},
      n = z.length,
      s = 0, I = 0, H = 0, p, t, i;

  for (i=0; i<n; ++i) {
    px[x[i]] = 0;
    py[y[i]] = 0;
  }

  for (i=0; i<n; ++i) {
    px[x[i]] += z[i];
    py[y[i]] += z[i];
    s += z[i];
  }

  t = 1 / (s * Math.LN2);
  for (i=0; i<n; ++i) {
    if (z[i] === 0) continue;
    p = (s * z[i]) / (px[x[i]] * py[y[i]]);
    I += z[i] * t * Math.log(p);
    H += z[i] * t * Math.log(z[i]/s);
  }

  return [I, 1 + I/H];
};

// Compute the mutual information between two discrete variables.
stats.mutual.info = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[0];
};

// Compute the mutual information distance between two discrete variables.
// MI_distance is defined as 1 - I(a,b) / H(a,b).
stats.mutual.dist = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[1];
};

// Compute a profile of summary statistics for a variable.
stats.profile = function(values, f) {
  var mean = 0,
      valid = 0,
      missing = 0,
      distinct = 0,
      min = null,
      max = null,
      M2 = 0,
      vals = [],
      u = {}, delta, sd, i, v, x;

  // compute summary stats
  for (i=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];

    // update unique values
    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);

    if (v == null) {
      ++missing;
    } else if (util.isValid(v)) {
      // update stats
      x = (typeof v === 'string') ? v.length : v;
      if (min===null || x < min) min = x;
      if (max===null || x > max) max = x;
      delta = x - mean;
      mean = mean + delta / (++valid);
      M2 = M2 + delta * (x - mean);
      vals.push(x);
    }
  }
  M2 = M2 / (valid - 1);
  sd = Math.sqrt(M2);

  // sort values for median and iqr
  vals.sort(util.cmp);

  return {
    type:     type(values, f),
    unique:   u,
    count:    values.length,
    valid:    valid,
    missing:  missing,
    distinct: distinct,
    min:      min,
    max:      max,
    mean:     mean,
    stdev:    sd,
    median:   (v = stats.quantile(vals, 0.5)),
    q1:       stats.quantile(vals, 0.25),
    q3:       stats.quantile(vals, 0.75),
    modeskew: sd === 0 ? 0 : (mean - v) / sd
  };
};

// Compute profiles for all variables in a data set.
stats.summary = function(data, fields) {
  fields = fields || util.keys(data[0]);
  var s = fields.map(function(f) {
    var p = stats.profile(data, util.$(f));
    return (p.field = f, p);
  });
  return (s.__summary__ = true, s);
};

module.exports = stats;
